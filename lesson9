词典
   散列：原理
   桶(bucket)：直接存放或间接指向一个词条
   桶数组 bucket array /散列表 hash table，容量为M
   N < M <<R
   空间 = O(N+M)=O(N) M与N尽量同阶
   定址根据词条的key直接确定散列表入口
   散列函数：hash(): key -> &entry
   实例：
    hash(key) = key % M;
    N/M 装填因子
    冲突 key1 != key2
    hash( key1) = hash( key2) 大定义域向小定义域映射
    散列函数设计：
      确定：同一关键码总是被映射至同一地址
      快速：
      满射：尽可能充分覆盖整个散列空间
      均匀：关键码映射到散列表各位置的概率尽量接近可有效避免clustering（局部汇聚）现象
    散列函数
      1 除余法
       hash(key) = key % M
       若取 M = 2 ^ k, 其效果相当于截取key的最后k位，前面n-k没有影响
       M-1 = 00000000000 111111
       key % M = key & (M-1)
       推论：发生冲突 iff 最后 k 位相同  第4条  
       key = a*M + b
       
       M取为素数，数据对散列表的覆盖最充分，分布最均匀
       S为序列步长
       gcd(S,M) = 1 S任意，M则为素数
       除余法缺陷
        1 不动点：无论表长M取值如何，总有hash(0) = 0;
        2 零阶均匀：[0，R)的关键码，平均分配至M个桶；但相邻关键码的
        散列地址也必须相邻
       
       MAD法
       一阶均匀：邻近的关键码，散列地址不再邻近
       取M为素数，a>0,b>0,a%M!=0
       hash( key ) =( a*key + b )% M
       
       数字分析
       抽取key中某几位。构成地址，例如取十进制的奇数位
       平方取中
       hash(123) = [123^2 = 1 512 9]  = 512
       
       折叠法
       将 分割成等宽的若干 段 并 求和
       位异或法
       将 分割成等宽的若干 二进制段 并求 异或 
       
       伪随机数
       循环 rand(x + 1) =[ a * rand(x)] % M
       hash(key) = rand(key) = [rand(0) * a^(key)] % M
       
       ------------------------------
       key ->hashcode->bucket addr
       hash( s =x0x1x2..xn-1) = x0*a^(n-1) + x1*a^(n-2)+..xn-1
       static size_t hashCode( char s[]){
         int h = 0;
         for ( size_t n = strlen(s), i = 0; i < n; i++){
            h = (h << 5)|(h >> 27);
            h + = (int) s[i];
         }
         return (size_t) h;
       }//????????????
       
       散列：排解冲突
       多槽位
       桶单元细分成若干槽位slot，存放（与同一单元）的词条
       独立链
       每个桶存放一个指针，冲突的词条组成列表
       优点：无需为每个桶预备多个槽位，任意多次的冲突都可解决，删除简单
       缺点：指针需要额外空间，节点需要动态申请，系统缓存几乎失效
       
       开放地址

高级搜索树
 局部性：
   Locality：刚被访问的数据，极有可能很快地再次被访问
 BST:
   刚刚被访问地节点，极有可能很快地再次被访问
   下一将要被访问地节点，极有可能就在刚被访问过的节点的附近
   m次查找 O(mlogn)
   逐层扩展：节点v一旦被访问，随即转移至树根
   自下而上，逐层单旋(zig,zag)
   最坏情况：
     旋转次数呈周期地算术级数演变，每个周期累计omg(n^2),分摊omg(n^2)
   构思精髓：向上追溯两层，而非一层
   zig-zag/zag-zig
   与AVL树双旋完全等效
   与一层等效
   zig-zig/zag-zag
   折叠效果：一旦访问坏节点，对应路径地长度将随机减半
   最坏情况不致持续发生
   单趟伸展操作，分摊O(logn);
   
   算法实现：
     template <typename T>
     class Splay: public BST<T>{
     protected: BinNodePosi(T) splay( BinNodePosi(T) v);//将v伸展至树根
     public: //伸展树地查找也会引起整树的结构调整，故search()也需要重写
     BinNodePosi(T) & search( const T & e);
     BinNodePosi(T) & insert( const T & e);
     bool remove( const T & e);
     } 
     template <typename T> BinNodePosi(T) Splay<T>::splay(BinNodePosi(T) v){
       if (! v) return NULL;
       BinNodePosi(T) p,g;
       while ((p = v->parent) && (g = p->parent)){ //自下而上，反复双层扩展
        BinNodePosi(T) gg = g->parent; //每轮之后，v都将以原曾祖父为父
        if( IsLChild( *v))
          if( IsRChild ( * p)){/*zig-zig*/ }else {/*zig-zag*/}
        else if(IsRChild ( *p)){/*zag-zag*/}else {/*zag-zig*/}
        if( !gg) v->parent = NULL; //若无曾祖父gg，则v 现即为树根；否则gg以v为孩子
        else( g == gg->lc) ? attachAsLChild(gg, v) : attachAsRChild(gg, v);
      }//双层伸展结束时，必有g==NULL，但p可能非空
      if( p = v->parent){/* 若p果真是根，只需在额外单旋（至多一次）*/}
      v->parent = NULL;return v;//伸展完成，v抵达树根
     }
    if (IslChild(* v))
      if (IsLChild( *p)){ //zig-zig
        attachAsLChild( g, p->rc);
        attachAsLChild( p, v->rc);
        attachAsRChild( p, g );
        attachAsRChild( v, p);
      }
      else{ /*zig-zag*/}
      else 
        if (IsRChild( *p)){/* zag-zig*/}
        else{ /*zag-zig*/}
     
     查找算法 非静态操作
     template <typename T> BinNodePosi(T) Splay<T>::search(const T & e){
     BinNodePosi(T) p = searchIn( _root, e, _hot = NULL);
     //无论成功与否，最后被访问的节点都将伸展至根
     _root = splay( p ? p : _hot);
     return _root;
     }
     插入算法
     删除算法
     
     局部性强，缓存命中率极高(即k << n << m)
     k 经常访问的数据范围  n 总数据范围 m访问
     效率甚至更高 --自适应的o(logk)
     任何连续的m次查找，都可在o(mlogk + nlogn)时间内完成
     --------------------------------------------------
     B-树
     严格意义非BST
     高速缓存
     1、内存与硬盘读写速度 10^5
     2、硬盘读写1B 与 1kB 几乎相同耗时
     
     平衡的多路搜索树
     二叉搜索树
      经适当合并，得超级节点
       每2代合并：4路
       每3代合并：8路
       每d代合并：m = 2^d路，m-1个关键码
       多级存储系统中使用B-树，可针对外部查找，大大减少I/O次数
       B-树利用对外存批量访问的高效性，每下降一层，都以超级节点为单位，读入一组关键码
       m阶B-树，m路平衡搜索树(m >= 2)
       外部节点和所有叶节点的深度统一相等（B树高度相对外节点）
       内部节点
         不超过m-1个关键码 k1,k2,k3,...kn
         不超过m个分支     A0,A1,A3,...An+1
       内部节点的分支数n+1也不能太少
         树根 :2 <= n + 1
         其余 ：上取整[m/2] <= n+1
       也称作([m/2],m)-树
       
       定义与实现
       BTNode节点定义
       template <typenname T> struct BTNode{
         BTNodePosi(T) parent; //父
         Vector<T> key; //数值向量
         Vector< BTNodePosi(T) > child;//孩子向量（其长度总比key多一）
         BTNode(){parent = NULL; child.insert(0, NULL);}
         BTNode(T e, BTNodePosi(T) lc = NULL, BTNodePosi(T) rc =NULL){
           parent = NULL;
           key.insert( 0 , e);
           child.insert( 0, lc);
           child.insert( 1, rc);
           if( lc) lc->parent = this;
           if (rc) rc->parent = this;
         }
       }
       BTree定义
       #define BTNodePosi(T) BTNode<T>*
       template <typename T> class BTree{
         protected:
           int _size; int _order;BTNodePosi(T) _root;
           //关键码总数、阶次、根
           BTNodePosi(T) _hot;//search()最后访问的非空节点
           void solveOverflow ( BTNodePosi(T));//因插入而上溢后的分裂处理
           void solveUnderflow ( BTNodePosi(T));//因删除而下溢后的合并处理
         public:
           BTNodePosi(T) search( const T & e);
           bool insert( const T & e );
           bool remove( const T & e );
       };
       查找：
        template <typename T> BTNodePosi(T)::search( const T & e)
        BTNodePosi(T) v = _root;  //从根节点出发
        _hot = NULL;
        while (v){
          Rank r = v->key.search(e);//从从当前节点对应的向量中顺序查找
          if ( 0 <= r && e == v->key[r]) return v;
          _hot = v; v = v->child[r + 1]; //沿引用转至对应的下层子树，并载入其根I/O
        } //因!v而退出，则意味着抵达外部节点   
        return NULL; //失败
        }
        最大树高
        
        
        
        
        
        最小树高
   

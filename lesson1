# 2018,10,2
算法：输入、输出、正确性、确定性、有穷性、可行性
考察有穷性：
Hailstone(n) = {
         1,n<=1;
         {n} U Hailstone(n/2),n is even;
         {n} U Hailstone(3n+1),n is odd ;
          }
Hailstone(42) : 42->21->64->32->16->8->4->2->1
int Hailstone(int n){
    int length = 1; 
    while (1 < n ){
       (n % 2) ? n = n*3+1 : n = n/2; length++; 
    } 
    return length;
}
Hailstone(7) = {7,22,11,34,....1}
Hailstone(27) ={27,82,.........}
---------------------------------------------
算法两个主要方面：正确性、成本（运行时间+存储空间）
考察：
   Ta(P) = 算法a求解实例P的计算成本（问题：P太多）
观察：
   问题实例的规模，往往是决定计算成本的主要因素
   Ta(n) = 算法a求解问题规模为n的实例 简记T(n)
   同一问题等规模不同实例，计算成本不尽相同
   => T(n)=max{ T(p)||P| = n}
   
  同一问题 , 不同算法
  观察： 不同算法适用不同规模，不同类型输入
        同一算法程序员、语言、平台、体系结构（硬件、操作系统等等）的不同
 抽象理想的平台或模型，不依赖具体因素
 
 TM: Turing Machine
 Tape  依次均匀地划分为单元格，各标注一个字符，默认“#”
 Alphabet 字符种类有限
 Head 总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或右侧的邻格
 State TM总是处于有限状态中的一种，每经过一个节拍，可（按规则）转向另一种状态
 Transition Function:(q,c : d,L/R,p)
 若当前状态为q且当前字符为c，则将当前字符改写为d;转向左侧/右侧的邻格；转入p状态；
 一旦转入特定的状态‘h’，则停机。
 example:
   function: 二进制非负整数加1   #####01111## （Head 在倒数第三位置）
   (<,1,0,L,<)
   (<,0,1,R,>)
   (>,0,0,R,>)
   (>,#,#,L,h)
  RAM: Random Access Machine
  寄存器顺序编号R[0]，R[1]，R[2]，R[3]
 一些基本操作R[i]<-c,R[i]<-R[R[j]],R[i]<-R[j]+R[k],IF GOTO
算法运行时间 -->算法需要执行的基本次数
---------------------------------------------
大O记号
渐进分析：足够大的问题，考察增长趋势
n->oo T(n),S(n)
定义：T(n) = O(f(n)) iff 存在 c>0,当n>>2，T（n）<c*f(n) 顶
     T(n) = omg(f(n)) iff 存在 c>0,当n>>2，T(n)>c*f(n) 底
     T(n) = theta(f(n)) iff 存在c1>c2>0,当n>>2，c2*f(n)<T(n)<c1*f(n) 拟合

O(1):常数
O(log^c(n)):对数（常底数，常数次幂无所谓）
O(n^c):多项式
O(2^n):指数
      2-Subset
S包含n个正整数，是否有两个子集使总和分半     
1.枚举 O(2^n) is NP-complete
---------------------------------------------
算法分析
正确性(不变性 x 单调性) + 复杂度

复杂度分析方法：
    迭代：级数求和
    递归：递归跟踪 + 递推方程
    猜测 + 验证
级数：
算术级数(与末项平方同阶)：T(n) = 1 + 2 + 3 + 4 + ..... + n =n(n+1)/2 = O(n^2)
幂方级数(比幂次高出一阶): T2(n) = 1^2 + 2^2 + .... +n^2 =n(n+1)(2n+1)/6 = O(n^3)
                        T3(n) = 1^3 + 2^3 + .... + n^3 = n^2(n+1)^2/4 = O(n^4)
                        T4(n) = 1^4 + 2^4 + .....+ n^4 = O(n^5)
几何级数(与末项同阶)：Ta(n) = a^0 + a^1 + .... + a^n = O(a^n)
收敛级数 O(1)
其他：
  调和级数：h(n) = 1 + 1/2 +1/3 + ... + 1/n = O(logn)
  对数级数： log1 + log2 + log3 + ..... +logn = log(n!) = O(nlogn)
1.for (int i = 0 ; i < n ;i<<=1)
   for(int j =0 ;j < i; j++)
      O1operation(i,j);   ------->>
      ---->1 + 2 + 4 + ... 2^[log2(n-1)] = 2^(log2(n))-1 =O(n)
2.  for (int i =0 ; i <= n; i++)
       for(int j=1;j < i; j+=j )
          O1operation(i,j);
      ---->O(nlogn)    
  -------------------------------------------------------------------------------
  起泡排序
  观察：消除无序序列中，相邻元素逆序
 void bubblesort(int A[] , int n ){
       for (bool sorted = false ; sorted = ! true ; n -- )
           for (int i = 1; i < n; i++ )
                if (A[i-1] > A[i]){
                swap(A[i-1],A[i]);
                sored = false;
                }
              }  
  不变性 ： 经k轮扫描交换后，最大的k个元素必然就位;
  单调性 ： 经k轮扫描交换后，问题规模缩至 n-k ;
  正确性 ： k<=n
  
封底估计
地球赤道周长 40000km
一天     10^5   sec
一生     3*10^9 sec
宇宙至今 10^21  sec
----------------------------------------------------
迭代与递归
数组求和：迭代
实现 ：
   int SumI(int A[] , int n){
       int sum = 0;
       for (int i = 0 ; i < n ;i++)
          sum + = A[i];
       return sum;   
   }
   空间复杂度 ： 除却输入，附加部分空间
 减而治之：(decrease and conquer)
       为求解一个大规模的问题，可以将其划分为两个子问题(单调性)：其一，平凡，另一
   规模缩减，分别求解子问题  由子问题的解，得到原问题的解。
int sum(int A[] , int n){
   return 
     (n < 1)?
     0 :sum(A , n-1) + A[n-1];
}

递归跟踪分析（应用有限）
   检查每个递归实例,累计所需时间(调用语句本身，计入对应的子实例)
其总和即算法执行时间  
T(n) = (n+1)*O(1) = O(n);

从递推角度看，求解sum(A,n),需
     递归求解规模为n-1的问题sum(A,n-1) , //T(n-1)
      再加上A[n-1]                      //O(1)
递归基 ：sum (A,0)                      //O(1)
递推方程  T(n) = T(n-1) + O(1)
         T(0) = O(1)
         T(n)-n = T(n-1)-(n-1) = ... = T(0)
         T(n) = O(1) + n = O(n)
 

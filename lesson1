# 2018,10,2
算法：输入、输出、正确性、确定性、有穷性、可行性
考察有穷性：
Hailstone(n) = {
         1,n<=1;
         {n} U Hailstone(n/2),n is even;
         {n} U Hailstone(3n+1),n is odd ;
          }
Hailstone(42) : 42->21->64->32->16->8->4->2->1
int Hailstone(int n){
    int length = 1; 
    while (1 < n ){
       (n % 2) ? n = n*3+1 : n = n/2; length++; 
    } 
    return length;
}
Hailstone(7) = {7,22,11,34,....1}
Hailstone(27) ={27,82,.........}
---------------------------------------------
算法两个主要方面：正确性、成本（运行时间+存储空间）
考察：
   Ta(P) = 算法a求解实例P的计算成本（问题：P太多）
观察：
   问题实例的规模，往往是决定计算成本的主要因素
   Ta(n) = 算法a求解问题规模为n的实例 简记T(n)
   同一问题等规模不同实例，计算成本不尽相同
   => T(n)=max{ T(p)||P| = n}
   
  同一问题 , 不同算法
  观察： 不同算法适用不同规模，不同类型输入
        同一算法程序员、语言、平台、体系结构（硬件、操作系统等等）的不同
 抽象理想的平台或模型，不依赖具体因素
 
 TM: Turing Machine
 Tape  依次均匀地划分为单元格，各标注一个字符，默认“#”
 Alphabet 字符种类有限
 Head 总是对准某一单元格，并可读取和改写其中的字符，每经过一个节拍，可转向左侧或右侧的邻格
 State TM总是处于有限状态中的一种，每经过一个节拍，可（按规则）转向另一种状态
 Transition Function:(q,c : d,L/R,p)
 若当前状态为q且当前字符为c，则将当前字符改写为d;转向左侧/右侧的邻格；转入p状态；
 一旦转入特定的状态‘h’，则停机。
 example:
   function: 二进制非负整数加1   #####01111## （Head 在倒数第三位置）
   (<,1,0,L,<)
   (<,0,1,R,>)
   (>,0,0,R,>)
   (>,#,#,L,h)
  RAM: Random Access Machine
  寄存器顺序编号R[0]，R[1]，R[2]，R[3]
 一些基本操作R[i]<-c,R[i]<-R[R[j]],R[i]<-R[j]+R[k],IF GOTO
算法运行时间 -->算法需要执行的基本次数
---------------------------------------------
大O记号
渐进分析：足够大的问题，考察增长趋势
n->oo T(n),S(n)
定义：T(n) = O(f(n)) iff 存在 c>0,当n>>2，T（n）<c*f(n)
     T(n) = omg(f(n)) iff 存在 c>0,当n>>2，T(n)>c*f(n)
     T(n) = theta(f(n)) iff 存在c1>c2>0,当n>>2，c2*f(n)<T(n)<c1*f(n)

O(1):常数
O(log^c(n)):对数（常底数，常数次幂无所谓）
O(n^c):多项式
O(2^n):指数
      2-Subset
      

 
 
